/*	°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°	PROJECT:	Ulis World		PURPOSE:	Replacement for system WDEF.		COPYRIGHT:	(C) Copyright 1996 by Uli Kusterer, all rights reserved.				This WDEF and its source code are FreeWare, but All rights				remain with their author. You may use derivatives of this				project or the project as it is here for any purpose you wish,				as long as you give credits to their author somewhere visible				to the users.					REACH ME AT:				COMPUSERVE:	101646,3646								REVISION HISTORY:				1.0		First public release. WDEF doesn't look good and has						just rudimentary graphics.				1.4		Removed CalcVisStrucRegion because it didn't consider						other apps' windows and so the grow box was drawn on top						of them when in background. Now uses the toolbox call						ClipAbove instead. Added white dropshadowembossed effect						to title. Now uses DrawRectParts instead of LineTo.						Window Still has 3-D borders when not highlighted. Added						four pixel frame around contentRegion. Grow box now part						of border. For compatibility with some apps, grow box						isn't drawn when frame is drawn (though recommended by						apple). Added dBoxProc, plainDBoxProc & altDBoxProc						variations.				1.5		Added Rallye stripes to make highlighted windows more						obvious. Corrected Errors in variation codes. Added						movableDBoxProc variation. Now uses bounds of contents						region instead of recalculating the window's rect every						time -> less calculations, more compatibility to						WindowShade. Grow box parts lying inside the content						region are clipped according to the clipRect. Only sets						Color Port when really needed. Some comments have						been corrected, too.				1.6		Fixed bug that caused initially invisible windows to be						uninitialized. -> moved check for (*window).visible				1.7		Fixed bug that had big ZoomBox always watching you.				1.8		Title bar height is now calculated using the System						Font's height.				1.81	Corrected bug in CheckColor that sometimes caused						crashes during app switching. Thanks to Tom Reahard.						Tweaked the title position to prevent						letters like g or y from colliding with border. Title						is now centered in the title bar horizontally and						vertically.				1.81b	(Godot) ported to CW (1.81 was base for 1.9, not this one).				1.9		Now uses 'cicn' resources for gadgets -> more complex						graphics.				2.0		Added support for custom window colors.				2.01	Ported to CW (used what Godot did on 1.81b). Added palette option.						Made window use grey color and not that strange one from the wctb.						Improved constants and their use a bit.				2.1		Added window "tinting" in colours specified by user.							°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°° */#pragma  mark	[Headers]#include <Palettes.h>#pragma  mark	[Compatibility Glue]// COMPILER FLAGS & TRICKS (Thanks to Godot for the following):#if		defined(__MWERKS__)#if			__powercPtr			osCurrentA5		:	0x0904;#define		GetGlobalPtr()				osCurrentA5#define		GetGlobalBase()				(*(Handle)osCurrentA5)#else	//	ISAPPCPtr			GetGlobalPtr(void):__A0			=	0x204d;				//	MOVE.L	A5, A0Ptr			GetGlobalBase(void):__A0		=	0x2055;				//	MOVE.L	(A5), A0#endif	//	ISAPPC#define	qd	(GetGlobalBase() - (sizeof(QDGlobals) + sizeof(GrafPtr)))	// Points to privates[76]#define	thePort			(*GetThePort())#define	qdGlobals		(GetGlobalBase() - (sizeof(QDGlobals) + sizeof(GrafPtr)))	// Points to privates[76]#define	whitePat		((Pattern *)(GetGlobalBase() - sizeof(Pattern)))#define	blackPat		((Pattern *)(GetGlobalBase() - (sizeof(Pattern) * 2)))#define	grayPat			((Pattern *)(GetGlobalBase() - (sizeof(Pattern) * 3)))#define	ltGrayPat		((Pattern *)(GetGlobalBase() - (sizeof(Pattern) * 4)))#define	dkGrayPat		((Pattern *)(GetGlobalBase() - (sizeof(Pattern) * 5)))#define	arrow			((Cursor *)(GetGlobalBase() - (sizeof(Cursor) + (sizeof(Pattern) * 5))))#define	screenBits		((BitMap *)(GetGlobalBase() - (sizeof(BitMap) + sizeof(Cursor) + (sizeof(Pattern) * 5))))#define	randSeed		(*(long *)(GetGlobalBase() - (sizeof(long) + sizeof(BitMap) + sizeof(Cursor) + (sizeof(Pattern) * 5))))#define	GlobalPtr		GetGlobalPtr()		// This would be better as GetGlobalPtrX, but MetroWorks' optimizer ain't that great (yet, V7)#endif	// defined(__MWERKS__)// Mix two colors:#define MixColors(colOne, colTwo)	\		(colTwo)->red = ((colTwo)->red + (colOne)->red) /2;	\		(colTwo)->green = ((colTwo)->green + (colOne)->green) /2;	\		(colTwo)->blue = ((colTwo)->blue + (colOne)->blue) /2;#pragma  mark	[Drawing Constants]// CONSTANTS FOR DRAWING#define FrontDark			true#define BackDark			true/*#define kFont				geneva#define kFontSize			10 */// If users want to create a palette, let them. Make font small.#ifdef kCompilePalette  #if kCompilePalette    #ifndef kSmallFont      #define kSmallFont		true    #endif    #ifndef kRallyeDots      #define kRallyeDots		true    #endif  #endif#else  #ifndef kRallyeDots    #define kRallyeDots			false  #endif  #ifndef kSmallFont    #define kSmallFont			false  #endif  #define kCompilePalette		false#endif// Make font small. Used for palettes.#if kSmallFont  #ifndef kFont    #define kFont				geneva  #endif  #ifndef kFontSize    #define kFontSize			9  #endif#else	// Set to system font  #ifndef kFont    #define kFont				0  #endif  #ifndef kFontSize    #define kFontSize			0  #endif#endif// "Shrink" box to minimize a window. ¥NOT YET IMPLEMENTED¥#ifndef kMinimizeGadget  #define kMinimizeGadget		false#endif// Size of grow box: Default to 16.#ifndef kGrowBoxSize#define kGrowBoxSize		16		// Size of the Grow Box#endif// Size of space around title bar.#ifndef kTitleNameBorder#define kTitleNameBorder	2		// Top & bottom borders for title#endif// Algorythm for calculation of title bar's height. Use a number to make it fixed.#ifndef kTitleBarHeight#define kTitleBarHeight		(MyFontData.ascent +MyFontData.descent +kTitleNameBorder +kTitleNameBorder)									// Height of the title Bar#endif#if FrontDark						// Use light color for active  #define kFrameCol		52428		// Color for the frame's Background  #define kShadeCol		39321		// Color for the frame's lower right parts#else								// Use dark color for active  #define kFrameCol		61166		// Color for the frame's Background  #define kShadeCol		52428		// Color for the frame's lower right parts#endif#if BlackHighlight					// Use black for rallye stripes	#define	kHighlightCol	30583	// Color for rallye stripes.#else								// Use light for rallye stripes	#define	kHighlightCol	0		// Color for rallye stripes.#endif#define kBlackCol		0			// Simple black#define kWhiteCol		65535		// Simple white#define kDimmedCol		32767		// Color for dimmed (Disabled) parts when the window's									// not highlighted#if BackDark						// Use dark color for inactive  #define kDimFrameCol	52428		// Color for background when window is not highlighted  #define kDimShadeCol	39321		// Color for the frame's lower right parts when disabled#else								// Use light color for inactive  #define kDimFrameCol	61166		// Color for background when window is not highlighted  #define kDimShadeCol	52428		// Color for the frame's lower right parts when disabled#endif// DrawRectParts possible choicesenum {	DR_Top			=	1,	DR_Left,	DR_TopLeft,	DR_Bottom,	DR_TopBot,	DR_LeftBot,	DR_TopLeftBot,	DR_Right,	DR_TopRight,	DR_LeftRight,	DR_TopLeftRight,	DR_BotRight,	DR_TopBotRight,	DR_LeftBotRight,	DR_Full};enum {	wHiliteColorLight = 5,	wHiliteColorDark,	wTitleBarLight,	wTitleBarDark,	wDialogLight,	wDialogDark,	wTingeLight,	wTingeDark};#pragma  mark	[Data Structure]// DATA STRUCTURE:typedef struct UlisWStateData {	Rect	userState;			// user state	Rect	stdState;			// standard state	Boolean	gadget;				// Gadget on while tracking?#if kMinimizeGadget	Boolean	minimized;			// Did user shrink our window?#endif} UlisWStateData, **UlisWStateDataHandle;#pragma  mark	[Prototypes]// FORWARD DECLARATIONSvoid DrawMessage ( short varCode, WindowPeek winPtr, Boolean hasColor );void DrawGoAwayMessage ( short varCode, WindowPeek winPtr, Boolean hasColor );void DrawZoomMessage ( short varCode, WindowPeek winPtr, Boolean hasColor );long HitMessage ( short varCode, WindowPeek winPtr, long param );void CalcRgnsMessage ( short varCode, WindowPeek winPtr, long param );void NewMessage ( short varCode, WindowPeek winPtr, long param );void DisposeMessage ( short varCode, WindowPeek winPtr, long param );void GrowRectMessage ( short varCode, WindowPeek winPtr, Rect *aRect );void GrowIconMessage ( short varCode, WindowPeek winPtr, long param, Boolean hasColor );void GlobalWRect ( WindowPeek winPtr, Rect *aRect );void GlobalContentRect ( WindowPeek winPtr, Rect *aRect );void SetColor ( short redColor, short greenColor, short blueColor );Boolean CheckColor ( WindowPeek winPtr );void SetColorPort ( Boolean hasColor );void CopyRect ( Rect *s, Rect *d);void DrawRectParts ( Rect *aRect, short choice );#pragma  mark	[Implementation]// -----------------------------------------------------------------------------------------------// This is the main procedure. It calls the routines which handle the requested tasks.// -----------------------------------------------------------------------------------------------pascal long main ( short varCode, WindowPtr theWindow, short message, long param ){	WindowPeek		winPtr;	Boolean			hasColor;	short			retVal = 0;	GrafPtr			oldPort;	RgnHandle		oldClip = NewRgn();		GetPort( &oldPort );	winPtr = (WindowPeek) theWindow;	hasColor = CheckColor ( winPtr );		// Now see that color port is set:	SetColorPort( hasColor );	GetClip( oldClip );		TextFont( kFont );	TextSize( kFontSize );		switch (message)	{		case wDraw:			if ((*winPtr).visible)			{				switch ( LoWord( param ) )				{					case 0:						DrawMessage (varCode, winPtr, hasColor);						break;											case wInGoAway:						DrawGoAwayMessage (varCode, winPtr, hasColor);						break;										case wInZoomIn:					case wInZoomOut:						DrawZoomMessage (varCode, winPtr, hasColor);						break;				}			}			break;				case wHit:			if ((*winPtr).visible)				retVal = HitMessage(varCode, winPtr, param);			break;				case wCalcRgns:			CalcRgnsMessage (varCode, winPtr, param);			break;				case wNew:			NewMessage (varCode, winPtr, param);			break;				case wDispose:			DisposeMessage (varCode, winPtr, param);			break;				case wGrow:			if ((*winPtr).visible)				GrowRectMessage (varCode, winPtr, (RectPtr) param);			break;				case wDrawGIcon:			if ((*winPtr).visible)			{				hasColor = CheckColor ( winPtr );				GrowIconMessage (varCode, winPtr, param, hasColor);			}			break;			}		// Restore previous fonts.	TextFont( 0 );	TextSize( 0 );		SetClip( oldClip );	DisposeRgn( oldClip );	SetPort( oldPort );	return (retVal);}// -----------------------------------------------------------------------------------------------// This is the procedure that calculates the structure and content regions of the different// window types.// -----------------------------------------------------------------------------------------------void CalcRgnsMessage ( short varCode, WindowPeek winPtr, long /*param*/ ){	Rect		aRect;	RgnHandle	myRgn;	FontInfo	MyFontData;		GlobalWRect ( winPtr, &aRect );		GetFontInfo ( &MyFontData );		RectRgn ( winPtr->contRgn, &aRect );		if ( varCode != 2 && varCode != 3 )		InsetRect ( &aRect, -6, -6);	else		InsetRect ( &aRect, -1, -1);		if ( varCode != 1 && varCode != 2 && varCode != 3 )	{		aRect.top += 5;		aRect.top -= kTitleBarHeight;	}		OpenRgn();		if( varCode == 5 || varCode == 13 || varCode == 1 )		FrameRoundRect( &aRect, 8, 8 );	else		FrameRoundRect( &aRect, 4, 4 );		CloseRgn( winPtr->strucRgn );		if ( varCode == 3 )	{		myRgn = NewRgn ();		OffsetRect ( &aRect, 2, 2 );		RectRgn( myRgn, &aRect );		UnionRgn( myRgn, winPtr->strucRgn, winPtr->strucRgn );		DisposeRgn( myRgn );	}}// -----------------------------------------------------------------------------------------------// This function returns in which part of the window the user clicked.// -----------------------------------------------------------------------------------------------long HitMessage ( short varCode, WindowPeek winPtr, long param ){	Rect		boundRect,				contentRect,				titleBarRect,				growIconRect,				closeBoxRect,				zoomBoxRect,				stdStateRect;	// For zooming	Point		myPos;	FontInfo	MyFontData;		GetFontInfo ( &MyFontData );		myPos.v = HiWord(param);	myPos.h = LoWord(param);		GlobalContentRect ( winPtr, &contentRect );		CopyRect ( &contentRect, &boundRect );	InsetRect ( &boundRect, -6, -6);		if ( varCode != 1 && varCode != 2 && varCode != 3 )		boundRect.top += 5;		if ( varCode != 1 && varCode != 2 && varCode != 3 )	{		titleBarRect.bottom = boundRect.top +kTitleNameBorder;		titleBarRect.top = boundRect.top -kTitleBarHeight;		titleBarRect.left = boundRect.left;		titleBarRect.right = boundRect.right;	}	else		SetRect ( &titleBarRect, 0, 0, 0, 0 );		CopyRect ( &contentRect, &growIconRect );	growIconRect.left = growIconRect.right - kGrowBoxSize;	growIconRect.top = growIconRect.bottom - kGrowBoxSize;		CopyRect ( &titleBarRect, &closeBoxRect );		closeBoxRect.left += 10;	closeBoxRect.top += 4;	closeBoxRect.bottom -= 4;	closeBoxRect.right = closeBoxRect.bottom -closeBoxRect.top +closeBoxRect.left;		CopyRect ( &titleBarRect, &zoomBoxRect );		zoomBoxRect.right -= 10;	zoomBoxRect.top += 4;	zoomBoxRect.bottom -= 4;	zoomBoxRect.left = zoomBoxRect.right -zoomBoxRect.bottom +zoomBoxRect.top;		if ( winPtr->hilited && varCode != 1 && varCode != 2 && varCode != 3 )	{		if ( PtInRect( myPos, &closeBoxRect ) && winPtr->goAwayFlag)			return ( wInGoAway );				if ( PtInRect( myPos, &zoomBoxRect ) && winPtr->spareFlag )		{			CopyRect ( &( (**((UlisWStateDataHandle) winPtr->dataHandle)).stdState ), &stdStateRect );			OffsetRect ( &stdStateRect, -stdStateRect.left, -stdStateRect.top );						if ( EqualRect ( &winPtr->port.portRect, &stdStateRect ) )				return ( wInZoomIn );			else				return ( wInZoomOut );		}	}		if ( PtInRect( myPos, &titleBarRect ) && varCode != 1 && varCode != 2 && varCode != 3 )		return ( wInDrag );		if ( winPtr->hilited && varCode != 1 && varCode != 2 && varCode != 3 )	{		if ( PtInRect( myPos, &growIconRect ) && !BitAnd( varCode, 4) )			return ( wInGrow );	}		if ( PtInRect( myPos, &contentRect ) )		return ( wInContent );		if ( PtInRect( myPos, &boundRect ) )	{		if ( varCode != 1 && varCode != 2 && varCode != 3 )			return ( wInDrag );		else			return ( wNoHit );	}}// -----------------------------------------------------------------------------------------------// This procedure draws the window frame and title.// -----------------------------------------------------------------------------------------------void DrawMessage ( short varCode, WindowPeek winPtr, Boolean hasColor ){	Rect			aRect,					titleBarRect,					boundsRect,					zoomBoxRect,					closeBoxRect,					tempRect;	RgnHandle		myErase,					svClip,					myClip,					tempRgn;	short			WindowWidth,					x,					winMid,					tleHeight;	Str255			windowName;	FontInfo		MyFontData;	CIconHandle		icon;	RGBColor		borderCol = { 0, 0, 0 },							// Border's inside.					shadeCol = { 65535, 65535, 65535 },					// Shadows.					highlightCol = { 0, 0, 0 },							// Rallye Stripes.					frameCol = { 0, 0, 0 },								// Surrounding lines.					lightsCol = { 65535, 65535, 65535 },				// Bright parts.					DimFrameCol = { 0, 0, 0 },							// Dimmed surrounding lines.					DimBorderCol = { 65535, 65535, 65535 },				// Dimmed border inside.					DimShadeCol = { 65535, 65535, 65535 },				// Dimmed shadows.					TextCol = { 0, 0, 0 },								// Window title.					DimTextCol = { 0, 0, 0 };							// Dimmed window title.	AuxWinHandle	awHdl;	CTabHandle		myColors;		borderCol.red = kFrameCol;	borderCol.green = kFrameCol;	borderCol.blue = kFrameCol;		DimBorderCol.red = kDimFrameCol;	DimBorderCol.green = kDimFrameCol;	DimBorderCol.blue = kDimFrameCol;		DimFrameCol.red = kDimmedCol;	DimFrameCol.green = kDimmedCol;	DimFrameCol.blue = kDimmedCol;		DimTextCol.red = kDimmedCol;	DimTextCol.green = kDimmedCol;	DimTextCol.blue = kDimmedCol;		lightsCol.red = kWhiteCol;	lightsCol.green = kWhiteCol;	lightsCol.blue = kWhiteCol;		if( GetAuxWin( (WindowPtr) winPtr, &awHdl ) )	{		myColors = (**awHdl).awCTable;				for( x = 0; x <= (**myColors).ctSize; x++ )		{			switch( (**myColors).ctTable[x].value )			{				case wFrameColor:					frameCol.red = (**myColors).ctTable[x].rgb.red;					frameCol.green = (**myColors).ctTable[x].rgb.green;					frameCol.blue = (**myColors).ctTable[x].rgb.blue;					break;								case wTextColor:					TextCol.red = (**myColors).ctTable[x].rgb.red;					TextCol.green = (**myColors).ctTable[x].rgb.green;					TextCol.blue = (**myColors).ctTable[x].rgb.blue;					break;								case wTingeDark:					highlightCol.red = (**myColors).ctTable[x].rgb.red;					highlightCol.green = (**myColors).ctTable[x].rgb.green;					highlightCol.blue = (**myColors).ctTable[x].rgb.blue;					break;								case wTingeLight:					shadeCol.red = (**myColors).ctTable[x].rgb.red;					shadeCol.green = (**myColors).ctTable[x].rgb.green;					shadeCol.blue = (**myColors).ctTable[x].rgb.blue;					DimShadeCol.red = (**myColors).ctTable[x].rgb.red;					DimShadeCol.green = (**myColors).ctTable[x].rgb.green;					DimShadeCol.blue = (**myColors).ctTable[x].rgb.blue;					break;			}		}	}		myErase = NewRgn();	svClip = NewRgn();	myClip = NewRgn();	tempRgn = NewRgn();		if( varCode == 5 || varCode == 13 )		TextFace( bold );		GlobalContentRect( winPtr, &aRect );		GetFontInfo( &MyFontData );	// Get info for system font.		// MixColors( highlightCol, borderCol );		// Now erase everything that's not content region:	DiffRgn( winPtr->strucRgn, winPtr->contRgn, myErase );	if( hasColor )	{		if( winPtr->hilited )			RGBForeColor( &borderCol );		else			RGBForeColor( &DimBorderCol );		PaintRgn( myErase );		if( winPtr->hilited )			RGBForeColor( &frameCol );		else			RGBForeColor( &DimFrameCol );	}	else		EraseRgn( myErase );		InsetRect( &aRect, -1, -1 );	FrameRect( &aRect );		if( varCode != 2 && varCode != 3 )	{		CopyRect( &aRect, &boundsRect );		InsetRect( &boundsRect, -5, -5 );				if( varCode != 1 )		{			boundsRect.top += 5;			boundsRect.top -= kTitleBarHeight;		}				if( varCode == 5 || varCode == 13 || varCode == 1 )			FrameRoundRect( &boundsRect, 8, 8 );		else			FrameRoundRect( &boundsRect, 4, 4 );				if( varCode != 1 )		{			CopyRect ( &boundsRect, &titleBarRect );			titleBarRect.bottom = titleBarRect.top +kTitleBarHeight +kTitleNameBorder;						CopyRect ( &titleBarRect, &closeBoxRect );			CopyRect ( &titleBarRect, &zoomBoxRect );						if ( !winPtr->goAwayFlag )				closeBoxRect.right = closeBoxRect.left +1;						if ( !winPtr->spareFlag )				zoomBoxRect.left = zoomBoxRect.right -1;									if ( winPtr->spareFlag )			{				zoomBoxRect.right -= 10;				zoomBoxRect.top += 4;				zoomBoxRect.bottom -= 4;				zoomBoxRect.left = zoomBoxRect.right -zoomBoxRect.bottom +zoomBoxRect.top;				if( ((zoomBoxRect.bottom -zoomBoxRect.top) /2) *2 == (zoomBoxRect.bottom -zoomBoxRect.top) )				{					zoomBoxRect.bottom -= 1;					zoomBoxRect.left += 1;				}				CopyRect ( &zoomBoxRect, &tempRect );				InsetRect( &tempRect, -1, -1 );				if ( winPtr->hilited )				{					icon = GetCIcon( -14332 );					RGBForeColor( &borderCol );				}				else				{					icon = GetCIcon( -14330 );					RGBForeColor( &DimBorderCol );				}				PaintRect( &tempRect );				if( icon != NULL )					PlotCIcon( &tempRect, icon );			}						if (winPtr->goAwayFlag)			{				closeBoxRect.left += 10;				closeBoxRect.top += 4;				closeBoxRect.bottom -= 4;				closeBoxRect.right = closeBoxRect.bottom -closeBoxRect.top +closeBoxRect.left;								if( ((closeBoxRect.bottom -closeBoxRect.top) /2) *2 == (closeBoxRect.bottom -closeBoxRect.top) )				{					closeBoxRect.bottom -= 1;					closeBoxRect.right -= 1;				}								CopyRect ( &closeBoxRect, &tempRect );				InsetRect( &tempRect, -1, -1 );				if ( winPtr->hilited )				{					icon = GetCIcon( -14335 );					RGBForeColor( &borderCol );				}				else				{					icon = GetCIcon( -14333 );					RGBForeColor( &DimBorderCol );				}				PaintRect( &tempRect );				if( icon != NULL )					PlotCIcon( &tempRect, icon );			}		} // Dialog exception				// Outter shades				CopyRect ( &boundsRect, &tempRect );		InsetRect ( &tempRect, 1, 1 );				if (hasColor)			if (winPtr->hilited)				RGBForeColor( &shadeCol );			else				RGBForeColor( &DimShadeCol );		else			PenPat( grayPat );				if( varCode == 5 || varCode == 13 || varCode == 1 )		{			tempRect.left += 1;			tempRect.right -= 1;		}		DrawRectParts( &tempRect, DR_Bottom );		if( varCode == 5 || varCode == 13 || varCode == 1 )		{			tempRect.left -= 1;			tempRect.right += 1;		}				if( varCode == 5 || varCode == 13 || varCode == 1 )		{			tempRect.top += 1;			tempRect.bottom -= 1;		}		DrawRectParts( &tempRect, DR_Right );		if( varCode == 5 || varCode == 13 || varCode == 1 )		{			tempRect.top -= 1;			tempRect.bottom += 1;		}				if( hasColor )		{			RGBForeColor( &lightsCol );						if( varCode == 5 || varCode == 13 || varCode == 1 )			{				tempRect.left += 1;				tempRect.right -= 1;			}			DrawRectParts( &tempRect, DR_Top );			if( varCode == 5 || varCode == 13 || varCode == 1 )			{				tempRect.left -= 1;				tempRect.right += 1;			}						if( varCode == 5 || varCode == 13 || varCode == 1 )			{				tempRect.top += 1;				tempRect.bottom -= 1;			}			DrawRectParts( &tempRect, DR_Left );			if( varCode == 5 || varCode == 13 || varCode == 1 )			{				tempRect.top -= 1;				tempRect.bottom += 1;			}						if( winPtr->hilited )				RGBForeColor( &frameCol );			else				RGBForeColor( &DimFrameCol );		}		else			PenPat ( blackPat );				// Inner shades				CopyRect ( &aRect, &tempRect );		InsetRect ( &tempRect, -1, -1 );				if (hasColor)			if (winPtr->hilited)				RGBForeColor( &shadeCol );			else				RGBForeColor( &DimShadeCol );		else			PenPat ( grayPat );				DrawRectParts ( &tempRect, DR_TopLeft );				if (hasColor)		{			RGBForeColor( &lightsCol );			DrawRectParts ( &tempRect, DR_BotRight );			if (winPtr->hilited)				RGBForeColor( &frameCol );			else				RGBForeColor( &DimFrameCol );		}		else			PenPat ( blackPat );				if ( varCode != 1 )		{			// Title						GetClip ( svClip );			CopyRect ( &titleBarRect, &tempRect );			tempRect.left = closeBoxRect.right +4;			tempRect.right = zoomBoxRect.left -4;			RectRgn ( myClip, &tempRect );						SectRgn ( svClip, myClip, myClip );			SetClip ( myClip );						GetWTitle ( (WindowPtr) winPtr, &windowName );			winPtr->titleWidth = StringWidth( &windowName );			WindowWidth = titleBarRect.right -titleBarRect.left;			winMid = titleBarRect.bottom -titleBarRect.top;			winMid /= 2;			tleHeight = MyFontData.ascent +MyFontData.descent;			tleHeight /= 2;			if ( winPtr->hilited )			{				RGBForeColor( &lightsCol );				MoveTo ( titleBarRect.left + (WindowWidth /2) +1, titleBarRect.bottom -winMid +tleHeight +1 );				Move ( -(winPtr->titleWidth /2), -MyFontData.descent );				SetColor ( kWhiteCol, kWhiteCol, kWhiteCol );				DrawString ( &windowName );				RGBForeColor( &TextCol );			}			else			{				RGBForeColor( &DimTextCol );			}			MoveTo ( titleBarRect.left + (WindowWidth /2), titleBarRect.bottom -winMid +tleHeight );			Move ( -(winPtr->titleWidth /2), -MyFontData.descent );			DrawString ( &windowName );						if ( winPtr->hilited )			{				RectRgn ( myClip, &titleBarRect );								CopyRect ( &closeBoxRect, &tempRect );				tempRect.left -= 2;				tempRect.right += 2;				RectRgn ( tempRgn, &tempRect );				DiffRgn ( myClip, tempRgn, myClip );								CopyRect ( &zoomBoxRect, &tempRect );				tempRect.left -= 2;				tempRect.right += 2;				RectRgn ( tempRgn, &tempRect );				DiffRgn ( myClip, tempRgn, myClip );								CopyRect ( &titleBarRect, &tempRect );				tempRect.left = titleBarRect.left + (WindowWidth /2) -(winPtr->titleWidth /2);				tempRect.right = tempRect.left +winPtr->titleWidth;				tempRect.left -= 5;				tempRect.right += 5;				RectRgn ( tempRgn, &tempRect );								DiffRgn ( myClip, tempRgn, myClip );				SectRgn ( svClip, myClip, myClip );				SetClip ( myClip );				#if kRallyeDots				PenPat( grayPat );#endif								if (hasColor)					RGBForeColor( &highlightCol );				x = titleBarRect.top +kTitleNameBorder +kTitleNameBorder;				while ( x < (titleBarRect.bottom -kTitleNameBorder -kTitleNameBorder) ) {					MoveTo ( titleBarRect.left +5, x );					LineTo ( titleBarRect.right -6, x );					x += 2;				}				if (hasColor) {					SetColor ( kWhiteCol, kWhiteCol, kWhiteCol );					x = titleBarRect.top +4;					while ( x < (titleBarRect.bottom -4) ) {						MoveTo ( titleBarRect.left +5, x+1 );						LineTo ( titleBarRect.right -5, x+1 );						x += 2;					}				}#if kRallyeDots				PenPat( blackPat );#endif								RGBForeColor( &frameCol );			}						SetClip ( svClip );		} // Dialog exception	} // Rect/Shadow exception		if ( varCode == 3 )	{		if( hasColor )			RGBForeColor( &shadeCol );		PenSize( 2, 2 );		CopyRect( &aRect, &tempRect );		tempRect.right += 1;		tempRect.bottom += 1;		tempRect.left += 2;		tempRect.top += 2;		DrawRectParts( &tempRect, DR_BotRight );		PenSize( 1, 1 );	}		if( hasColor )		SetColor( 0, 0, 0 );		// For window Manager		if( varCode == 5 || varCode == 13 )		TextFace( normal );		DisposeRgn ( myErase );	DisposeRgn ( myClip );	DisposeRgn ( svClip );	DisposeRgn ( tempRgn );}// -----------------------------------------------------------------------------------------------// This procedure highlights the close box and unhilites it.// -----------------------------------------------------------------------------------------------void DrawGoAwayMessage ( short /*varCode*/, WindowPeek winPtr, Boolean /*hasColor*/ ){	Rect			aRect,					closeBoxRect,					titleBarRect;	FontInfo		MyFontData;	CIconHandle		icon;	RGBColor		borderCol = { 65535, 65535, 65535 };	AuxWinHandle		awHdl;	CTabHandle		myColors;	short			x;		if( GetAuxWin( (WindowPtr) winPtr, &awHdl ) )	{		myColors = (**awHdl).awCTable;				for( x = 0; x <= (**myColors).ctSize; x++ )		{			switch( (**myColors).ctTable[x].value )			{				case wTitleBarColor:					borderCol.red = (**myColors).ctTable[x].rgb.red;					borderCol.green = (**myColors).ctTable[x].rgb.green;					borderCol.blue = (**myColors).ctTable[x].rgb.blue;					break;			}		}	}		GetFontInfo ( &MyFontData );	GlobalContentRect ( winPtr, &aRect);		InsetRect ( &aRect, -6, -6);	aRect.top += 5;		titleBarRect.bottom = aRect.top +kTitleNameBorder;	titleBarRect.top = aRect.top -kTitleBarHeight;	titleBarRect.left = aRect.left;	titleBarRect.right = aRect.right;		CopyRect ( &titleBarRect, &closeBoxRect );		closeBoxRect.left += 10;	closeBoxRect.top += 4;	closeBoxRect.bottom -= 4;	closeBoxRect.right = closeBoxRect.bottom -closeBoxRect.top +closeBoxRect.left;		if( ((closeBoxRect.bottom -closeBoxRect.top) /2) *2 == (closeBoxRect.bottom -closeBoxRect.top) )	{		closeBoxRect.bottom -= 1;		closeBoxRect.right -= 1;	}		InsetRect( &closeBoxRect, -1, -1 );		if( !(**(UlisWStateDataHandle) winPtr->dataHandle).gadget )		icon = GetCIcon( -14334 );	else		icon = GetCIcon( -14335 );		RGBForeColor( &borderCol );	PaintRect( &closeBoxRect );	if( icon != NULL )		PlotCIcon( &closeBoxRect, icon );		(**(UlisWStateDataHandle) winPtr->dataHandle).gadget = !(**(UlisWStateDataHandle) winPtr->dataHandle).gadget;}// -----------------------------------------------------------------------------------------------// This procedure highlights the zoom box and unhilites it.// -----------------------------------------------------------------------------------------------void DrawZoomMessage ( short /*varCode*/, WindowPeek winPtr, Boolean /*hasColor*/ ){	Rect			aRect,					zoomBoxRect,					titleBarRect;	FontInfo		MyFontData;	CIconHandle		icon;	RGBColor		borderCol = { 65535, 65535, 65535 };	AuxWinHandle		awHdl;	CTabHandle		myColors;	short			x;		if( GetAuxWin( (WindowPtr) winPtr, &awHdl ) )	{		myColors = (**awHdl).awCTable;				for( x = 0; x <= (**myColors).ctSize; x++ )		{			switch( (**myColors).ctTable[x].value )			{				case wTitleBarColor:					borderCol.red = (**myColors).ctTable[x].rgb.red;					borderCol.green = (**myColors).ctTable[x].rgb.green;					borderCol.blue = (**myColors).ctTable[x].rgb.blue;					break;			}		}	}					GetFontInfo ( &MyFontData );	GlobalContentRect ( winPtr, &aRect);		InsetRect ( &aRect, -6, -6);	aRect.top += 5;		titleBarRect.bottom = aRect.top +kTitleNameBorder;	titleBarRect.top = aRect.top -kTitleBarHeight;	titleBarRect.left = aRect.left;	titleBarRect.right = aRect.right;		CopyRect ( &titleBarRect, &zoomBoxRect );		zoomBoxRect.right -= 10;	zoomBoxRect.top += 4;	zoomBoxRect.bottom -= 4;	zoomBoxRect.left = zoomBoxRect.right -zoomBoxRect.bottom +zoomBoxRect.top;		if( ((zoomBoxRect.bottom -zoomBoxRect.top) /2) *2 == (zoomBoxRect.bottom -zoomBoxRect.top) )	{		zoomBoxRect.bottom -= 1;		zoomBoxRect.left += 1;	}		InsetRect( &zoomBoxRect, -1, -1 );		if( !(**(UlisWStateDataHandle) winPtr->dataHandle).gadget )		icon = GetCIcon( -14331 );	else		icon = GetCIcon( -14332 );		RGBForeColor( &borderCol );	PaintRect( &zoomBoxRect );	if( icon != NULL )		PlotCIcon( &zoomBoxRect, icon );		(**(UlisWStateDataHandle) winPtr->dataHandle).gadget = !(**(UlisWStateDataHandle) winPtr->dataHandle).gadget;}/* ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ	This procedure initializes the WStateData record and sets the flags of the	window Record depending on the variation code.ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ */void NewMessage ( short varCode, WindowPeek winPtr, long /*param*/ ){	UlisWStateDataHandle	myWData;	Rect					aRect;		GlobalWRect ( winPtr, &aRect);		// WState Record for zooming		winPtr->dataHandle = NewHandleClear( sizeof( UlisWStateData ) );		myWData = (UlisWStateDataHandle) winPtr->dataHandle;	CopyRect ( &aRect, &(**myWData).userState );	CopyRect ( &aRect, &(**myWData).stdState );	(**myWData).gadget = false;					// Close flag (for movable modal)		if ( varCode == 5 || varCode == 13 )	{		winPtr->goAwayFlag = false;	}		// Zoom flag		if ( BitAnd( varCode, 8) )	{		winPtr->spareFlag = true;	}	}/* ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ	This procedure disposes tha data allocated on NewMessage.ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ */void DisposeMessage ( short /*varCode*/, WindowPeek winPtr, long /*param*/ ){	DisposHandle ( winPtr->dataHandle );}void GrowRectMessage ( short varCode, WindowPeek /*winPtr*/, Rect *aRect ){	Rect		boundsRect,				outterRect,				gBoxRect;	FontInfo	MyFontData;		GetFontInfo ( &MyFontData );	CopyRect ( aRect, &boundsRect);		InsetRect ( &boundsRect, -1, -1 );	FrameRect ( &boundsRect );		CopyRect ( &boundsRect, &outterRect );		InsetRect ( &outterRect, -5, -5 );	outterRect.top += 5;	outterRect.top -= kTitleBarHeight;	if (varCode != 1 && varCode != 2 && varCode != 3)		FrameRect ( &outterRect );		CopyRect ( &boundsRect, &gBoxRect );	gBoxRect.left = gBoxRect.right -kGrowBoxSize;	gBoxRect.top = gBoxRect.bottom -kGrowBoxSize;	FrameRect ( &gBoxRect );		MoveTo ( boundsRect.left +1, boundsRect.bottom -kGrowBoxSize );	LineTo ( boundsRect.right -kGrowBoxSize -1, boundsRect.bottom -kGrowBoxSize );	MoveTo ( boundsRect.right -kGrowBoxSize, boundsRect.top +1 );	LineTo ( boundsRect.right -kGrowBoxSize, boundsRect.bottom -kGrowBoxSize -1 );}// -----------------------------------------------------------------------------------------------// This procedure draws the grow box and the lines for the scroll bar regions.// -----------------------------------------------------------------------------------------------void GrowIconMessage ( short /*varCode*/, WindowPeek winPtr, long /*param*/, Boolean /*hasColor*/ ){	Rect			aRect,					growIconRect;	Point			offset = { 0, 0 };	RgnHandle		svClip,					winClip,					myClip,					contRgn;	GrafPtr			oldPort;	CIconHandle		icon;	RGBColor		oldColor,					borderCol = { 65535, 65535, 65535 },					DimBorderCol = { 65535, 65535, 65535 },					frameCol = { 0, 0, 0 },					DimFrameCol = { 0, 0, 0 };	CTabHandle		myColors;	AuxWinHandle	awHdl;	short			x;		if( GetAuxWin( (WindowPtr) winPtr, &awHdl ) )	{		myColors = (**awHdl).awCTable;				for( x = 0; x <= (**myColors).ctSize; x++ )		{			switch( (**myColors).ctTable[x].value )			{				case wFrameColor:					frameCol.red = (**myColors).ctTable[x].rgb.red;					frameCol.green = (**myColors).ctTable[x].rgb.green;					frameCol.blue = (**myColors).ctTable[x].rgb.blue;					break;								case wTitleBarColor:					borderCol.red = (**myColors).ctTable[x].rgb.red;					borderCol.green = (**myColors).ctTable[x].rgb.green;					borderCol.blue = (**myColors).ctTable[x].rgb.blue;					DimBorderCol.red = (**myColors).ctTable[x].rgb.red;					DimBorderCol.green = (**myColors).ctTable[x].rgb.green;					DimBorderCol.blue = (**myColors).ctTable[x].rgb.blue;					break;								case wTingeDark:					DimFrameCol.red = (**myColors).ctTable[x].rgb.red;					DimFrameCol.green = (**myColors).ctTable[x].rgb.green;					DimFrameCol.blue = (**myColors).ctTable[x].rgb.blue;					break;			}		}	}		svClip = NewRgn();	winClip = NewRgn();	myClip = NewRgn();	contRgn = NewRgn();	GetClip( svClip );		GlobalContentRect ( winPtr, &aRect);	InsetRect ( &aRect, -1, -1);		CopyRect ( &aRect, &growIconRect );	growIconRect.left = growIconRect.right - kGrowBoxSize;	growIconRect.top = growIconRect.bottom - kGrowBoxSize;		growIconRect.right += 1;	growIconRect.bottom += 1;		GetPort( &oldPort );	SetPort( (GrafPtr) winPtr );	GetForeColor( &oldColor );		if (winPtr->hilited)	{		RGBForeColor( &frameCol );				MoveTo( winPtr->port.portRect.left, winPtr->port.portRect.bottom -kGrowBoxSize +1 );		LineTo( winPtr->port.portRect.right, winPtr->port.portRect.bottom -kGrowBoxSize +1 );		MoveTo( winPtr->port.portRect.right -kGrowBoxSize +1, winPtr->port.portRect.top );		LineTo( winPtr->port.portRect.right -kGrowBoxSize +1, winPtr->port.portRect.bottom );				icon = GetCIcon( -14329 );	}	else	{		RGBForeColor( &DimFrameCol );				MoveTo( winPtr->port.portRect.left, winPtr->port.portRect.bottom -kGrowBoxSize +1 );		LineTo( winPtr->port.portRect.right, winPtr->port.portRect.bottom -kGrowBoxSize +1 );		MoveTo( winPtr->port.portRect.right -kGrowBoxSize +1, winPtr->port.portRect.top );		LineTo( winPtr->port.portRect.right -kGrowBoxSize +1, winPtr->port.portRect.bottom );				icon = GetCIcon( -14328 );	}	RGBForeColor( &oldColor );	SetPort( oldPort );		SetClip( winPtr->strucRgn );			// Set clip rgn.	ClipAbove( (WindowPtr) winPtr );		// Remove covered parts.		RGBForeColor( &borderCol );	PaintRect( &growIconRect );	if( icon != NULL )		PlotCIcon( &growIconRect, icon );		SetColor( 0, 0, 0 );					// Reset window Mgr's color.	SetClip ( svClip );		DisposeRgn( svClip );	DisposeRgn( winClip );	DisposeRgn( myClip );	DisposeRgn( contRgn );}// -----------------------------------------------------------------------------------------------// This procedure returns the rect of the window in global coordinates.// -----------------------------------------------------------------------------------------------void GlobalWRect ( WindowPeek winPtr, Rect *aRect ){	GrafPtr		svPort;	Point		tempPoint;			GetPort ( &svPort );	SetPort ( (GrafPtr) winPtr );		CopyRect ( &(winPtr->port.portRect), aRect );		SetPt ( &tempPoint, 0, 0 );	LocalToGlobal ( &tempPoint );		OffsetRect ( aRect, tempPoint.h, tempPoint.v );		SetPort ( svPort );}// -----------------------------------------------------------------------------------------------// This procedure returns the rect of the window based on the content region. This assures// compatibility to WindowShade and consorts.// -----------------------------------------------------------------------------------------------void GlobalContentRect ( WindowPeek winPtr, Rect *aRect ){	CopyRect ( &((**winPtr->contRgn).rgnBBox), aRect); // Copy region bounds}// -----------------------------------------------------------------------------------------------// This procedure sets the foreground color to an RGB value passed as three different shorts.// -----------------------------------------------------------------------------------------------void SetColor ( short redColor, short greenColor, short blueColor ){	RGBColor		myColor;		myColor.red = redColor;	myColor.green = greenColor;	myColor.blue = blueColor;		RGBForeColor ( &myColor );}// -----------------------------------------------------------------------------------------------// This function returns whether the screens the window is displayed on support 4 Bit or more.// -----------------------------------------------------------------------------------------------Boolean CheckColor ( WindowPeek winPtr ){        OSErr           theErr;        Boolean         hasColor;        GDHandle        aDevice;        long            theVal;        theErr = Gestalt( 'qdrw', &theVal );        hasColor = ( BitAnd( theVal, 1 ) != 0 );        aDevice = GetMaxDevice( &((**(winPtr->strucRgn)).rgnBBox) );		// Following fix by Tom Reahard:		if ( aDevice )			hasColor = (hasColor && ((**((**aDevice).gdPMap)).pixelSize >= 4));        return (hasColor);}// -----------------------------------------------------------------------------------------------// This procedure sets the GrapfPort to the Color Window Manager's port, if hasColor is TRUE.// -----------------------------------------------------------------------------------------------void SetColorPort ( Boolean hasColor ){	CGrafPtr	aPort;	RgnHandle	myClip;	PenState	pnState;		if ( hasColor == true )	{		myClip = NewRgn();				GetCWMgrPort ( &aPort );				GetPenState ( &pnState );		GetClip ( myClip );				SetPort ( (GrafPtr) aPort );				SetPenState ( &pnState );		SetClip ( myClip );				DisposeRgn( myClip );	}}// -----------------------------------------------------------------------------------------------// This procedure copies the data from one rect to the other.// -----------------------------------------------------------------------------------------------void CopyRect ( Rect *s, Rect *d){	(*d).left = (*s).left;	(*d).top = (*s).top;	(*d).right = (*s).right;	(*d).bottom = (*s).bottom;}// -----------------------------------------------------------------------------------------------// This procedure draws only the specified sides of a rect. It requires the enum at the beginning// Of this script.// -----------------------------------------------------------------------------------------------void DrawRectParts ( Rect *aRect, short choice ){	if ( BitAnd(choice, 1) ) {		MoveTo ( (*aRect).left, (*aRect).top );		LineTo ( (*aRect).right -1, (*aRect).top );	}	if ( BitAnd(choice, 2) ) {		MoveTo ( (*aRect).left, (*aRect).top );		LineTo ( (*aRect).left, (*aRect).bottom -1 );	}	if ( BitAnd(choice, 4) ) {		MoveTo ( (*aRect).left, (*aRect).bottom -1 );		LineTo ( (*aRect).right -1, (*aRect).bottom -1 );	}	if ( BitAnd(choice, 8) ) {		MoveTo ( (*aRect).right -1, (*aRect).top );		LineTo ( (*aRect).right -1, (*aRect).bottom -1 );	}}