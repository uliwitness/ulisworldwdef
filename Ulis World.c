/*	∞∞∞∞∞∞∞∞∞∞∞∞∞∞∞∞∞∞∞∞∞∞∞∞∞∞∞∞∞∞∞∞∞∞∞∞∞∞∞∞∞∞∞∞∞∞∞∞∞∞∞∞∞∞∞∞∞∞∞∞∞∞∞∞∞∞∞∞∞∞∞∞∞∞∞	PROJECT:	Uli's World WDEF		PURPOSE:	System WDEF replacement			COPYRIGHT:	(C) Copyright 1998-99 by M. Uli Kusterer, all rights reserved.						REACH ME AT:				E-MAIL:		witness@weblayout.com				URL:		http://www.weblayout.com/witness			REVISIONS:		98-01-30	UK		Took the shell from the old 'Uli's World' WDEF and							rewrote it to support the Appearance extensions and							cleaned up everything.					∞∞∞∞∞∞∞∞∞∞∞∞∞∞∞∞∞∞∞∞∞∞∞∞∞∞∞∞∞∞∞∞∞∞∞∞∞∞∞∞∞∞∞∞∞∞∞∞∞∞∞∞∞∞∞∞∞∞∞∞∞∞∞∞∞∞∞∞∞∞∞∞ */#pragma mark [Headers]/* ————————————————————————————————————————————————————————————————————————————————	Headers:   ————————————————————————————————————————————————————————————————————————————— */#include	"Ulis World.h"#include	<sound.h>#pragma mark [Globals]/* ————————————————————————————————————————————————————————————————————————————————	Globals:   ————————————————————————————————————————————————————————————————————————————— */Boolean		gHasColor = false;FontInfo	gFontData;short		gMaxBitDepth = 1;short		gVariation = 0;WindowPtr	gWindow;long		gParam;Boolean		gCollapsed;const RGBColor		kGrayColor = { 30583, 30583, 30583 };const RGBColor		kContentColor = { 61166, 61166, 61166 };const RGBColor		kDisabledColor = { 32768, 32768, 32768 };const RGBColor		kGadgetColor = { 43690, 43690, 43690 };#pragma mark -#pragma mark [Implementation]/* ————————————————————————————————————————————————————————————————————————————————	Main:		This is the entry point of this WDEF. It dispatches calls to the		appropriate functions			REVISIONS:		98-01-30	UK		Created.   ————————————————————————————————————————————————————————————————————————————— */pascal long	main( short varCode, WindowPtr theWindow, short message, long param ){	long			retVal = 0,					oldFont,					oldSize;	GrafPtr			oldPort,					thisPort;	RgnHandle		oldClip = NewRgn();		if( !oldClip )		return memFullErr;		// Set up values for globals:	GetPort( &oldPort );	gHasColor = CheckColor( theWindow );	gVariation = varCode;	gWindow = theWindow;	gParam = param;	gCollapsed = IsWindowCollapsed( gWindow );		// Now see that color port is set:	retVal = SetColorPort();	if( retVal != 0 )	{		DisposeRgn( oldClip );		return retVal;	}	GetClip( oldClip );		GetPort( &thisPort );	oldFont = thisPort->txFont;	oldSize = thisPort->txSize;	  #if _UW_CUSTOM_FONT	TextFont( kCustomFontID );	TextSize( kCustomFontSize );  #else	TextFont( LMGetSysFontFam() );	TextSize( LMGetSysFontSize() );  #endif		GetFontInfo( &gFontData );		switch( message )	{		case wDraw:			if( IsWindowVisible( theWindow ) )			{				switch( LoWord( param ) )				{					case 0:						DrawWindowFrame();						break;											case wInGoAway:						DrawCloseBox();						break;										case wInZoomIn:					case wInZoomOut:						DrawZoomBox();						break;										case wInCollapseBox:						retVal = DrawCollapseBox();						break;				}			}			break;				case wHit:			if( IsWindowVisible( theWindow ) )				retVal = ClickInWindow( (*((Point*) &param)) );			break;				case wCalcRgns:			CalcRegionsMessage();			break;				case wNew:			retVal = Initialize();			break;				case wDispose:			Dispose();			break;				case wGrow:			if( IsWindowVisible( theWindow ) )				DrawGrowRect( (Rect*) param );			break;				case wDrawGIcon:			if( IsWindowVisible( theWindow ) )			{				SetPort( gWindow );				DrawScrollbarLines( NULL );				SetPort( thisPort );			}			break;				case kWindowMsgGetFeatures:			(*(long*) param) = ReturnWindowFeatures();			retVal = 1;			break;				case kWindowMsgGetRegion:			GetMyWindowRegion( (GetWindowRegionRec*) gParam );			break;	}		// Restore previous fonts.	TextFont( oldFont );	TextSize( oldSize );		SetClip( oldClip );	DisposeRgn( oldClip );	SetPort( oldPort );		return( retVal );}/* ————————————————————————————————————————————————————————————————————————————————	GetWindowRegion:		Return the regions of a certain window part:			REVISIONS:		98-01-30	UK		Created.   ————————————————————————————————————————————————————————————————————————————— */void	GetMyWindowRegion( GetWindowRegionPtr rgnRec ){	switch( rgnRec->regionCode )	{		case kWindowTitleBarRgn:			CalcTitleBarRegion( rgnRec->winRgn );			break;				case kWindowTitleTextRgn:			CalcTitleTextRegion( rgnRec->winRgn );			break;				case kWindowCloseBoxRgn:			CalcCloseBoxRegion( rgnRec->winRgn );			break;				case kWindowZoomBoxRgn:			CalcZoomBoxRegion( rgnRec->winRgn );			break;				case kWindowDragRgn:			CalcDragRegion( rgnRec->winRgn );			break;				case kWindowGrowRgn:			CalcGrowRegion( rgnRec->winRgn );			break;				case kWindowCollapseBoxRgn:			CalcCollapseBoxRegion( rgnRec->winRgn );			break;				case kWindowStructureRgn:			CalcStructureRegion( rgnRec->winRgn );			break;				case kWindowContentRgn:			CalcContentRegion( rgnRec->winRgn );			break;			}}/* ————————————————————————————————————————————————————————————————————————————————	ClickInWindow:		Return which part of the window was hit. This uses rects where possible		because region hit tests are rather slow.			REVISIONS:		98-01-31	UK		Created.   ————————————————————————————————————————————————————————————————————————————— */long	ClickInWindow( Point hitPos ){	Rect		box;		GetGlobalWRect( &box );	if( PtInRect( hitPos, &box ) )	{		GetGrowBoxRect( &box, false );		if( PtInRect( hitPos, &box ) && BIT_TEST( gVariation, kUlisHasGrowBox ) && IsWindowHilited( gWindow ) )			return wInGrow;		else			return wInContent;	}	else	{		GetCloseBoxRect( &box );		if( PtInRect( hitPos, &box ) && IsWindowHilited( gWindow )			&& GetWindowGoAwayFlag( gWindow ) )			return wInGoAway;		else		{			GetZoomBoxRect( &box );			if( PtInRect( hitPos, &box ) && IsWindowHilited( gWindow )				&& GetWindowZoomFlag( gWindow ) )			{				return GetCurrentZoomState();			}			else			{				GetCollapseBoxRect( &box );				if( PtInRect( hitPos, &box ) && IsWindowHilited( gWindow ) )				{					return wInCollapseBox;				}				else					return wInDrag;			}		}	}}/* ————————————————————————————————————————————————————————————————————————————————	Initialize:		Initialize any data that may be needed. (WStateData record etc.) This		actually initializes the zooming fields to the window rect. I hope that		will finally yield the expected zooming behaviour.			REVISIONS:		98-01-30	UK		Created.   ————————————————————————————————————————————————————————————————————————————— */long	Initialize(){	UlisWStateDataHandle	theHand = (UlisWStateDataHandle) NewHandleClear( sizeof( UlisWStateData ) );	Rect					box;	RgnHandle				grayRgn = GetGrayRgn();		// Set zoom box flag if variation requests zoom:	((WindowPeek) gWindow)->spareFlag = BIT_TEST( gVariation, kUlisHasHorzZoomBox )										|| BIT_TEST( gVariation, kUlisHasVertZoomBox );		// Set up data handle:	((WindowPeek) gWindow)->dataHandle = (Handle) theHand;		if( !theHand )		return( memFullErr );		if( ((WindowPeek) gWindow)->spareFlag )	{		// Set user state to our rect:		GetGlobalWRect( &box );		(**theHand).userState = box;				// Set std state to screen area:		box = (**grayRgn).rgnBBox;		box.top += LMGetMBarHeight();		InsetRect( &box, 4, 4 );		(**theHand).stdState = box;	}		// Make sure this flag looks right on gadget click:	(**theHand).gadget = true;		return( noErr );}/* ————————————————————————————————————————————————————————————————————————————————	Dispose:		Dispose of any data that we have allocatd on Initialize(). (WStateData		record etc.)			REVISIONS:		98-01-31	UK		Created.   ————————————————————————————————————————————————————————————————————————————— */void	Dispose(){	Handle		theHandle = ((WindowPeek) gWindow)->dataHandle;		if( theHandle )		DisposeHandle( theHandle );}/* ————————————————————————————————————————————————————————————————————————————————	ReturnWindowFeatures:		Return the features this window supports. Some depend on the variation		code passed, so be careful not to set everything.			REVISIONS:		98-01-31	UK		Created.   ————————————————————————————————————————————————————————————————————————————— */long	ReturnWindowFeatures(){	long		retVal = 0;		// If user chose the correct variation, we may have a grow box:	if( BIT_TEST( gVariation, kUlisHasGrowBox ) )		retVal |= kWindowCanGrow;		/* If user chose the correct variation, we may have a zoom box. Notice that		we only check for horizontal and vertical zoom boxes, not for full zoom		boxes since kUlisHasFullZoomBox is just both flags added up. */	if( BIT_TEST( gVariation, kUlisHasVertZoomBox )		|| BIT_TEST( gVariation, kUlisHasHorzZoomBox ) )		retVal |= kWindowCanZoom;		// Our window always supports collapsing:	retVal |= kWindowCanCollapse;		/* This WDEF automatically supports the new region accessors and the		old-style message. */	retVal |= kWindowCanGetWindowRegion;		// This window type has a title bar:	retVal |= kWindowHasTitleBar;		/* If we supported modal dialogs, we would check the variation and set this		flag: */	// retVal |= kWindowIsModal;		/* If we supported alert WDEFs, we would check the variation and set this		flag. */	// retVal |= kWindowIsAlert;		return retVal;}#pragma mark -#pragma mark [Drawing]/* ————————————————————————————————————————————————————————————————————————————————	DrawGrowRect:		Draw the 'window shadow' the user will see when resizing the window:			REVISIONS:		98-01-30	UK		Created.   ————————————————————————————————————————————————————————————————————————————— */void	DrawGrowRect( Rect* frame ){	Rect		box = *frame;		InsetRect( &box, -1, -1 );	FrameRect( &box );	  #if _UW_THICK_BORDER	{		short		svTop;				box = *frame;		GetTitleBarRect( &box, true );	// Calc title bar's rect for this one.		svTop = box.top;				box = *frame;		InsetRect( &box, -kBorderWidth -1, -kBorderWidth -1 );		box.top = svTop;		FrameRect( &box );	}  #else	{		box = *frame;		GetTitleBarRect( &box, true );	// Calc title bar's rect for this one.		DrawRectParts( &box, DR_TopLeftRight );	}  #endif		DrawScrollbarLines( frame );}/* ————————————————————————————————————————————————————————————————————————————————	DrawWindowFrame:		Draw the window.			REVISIONS:		98-01-30	UK		Created.   ————————————————————————————————————————————————————————————————————————————— */void	DrawWindowFrame(){	RgnHandle	theRgn = NewRgn();	RGBColor	grayCol = kGrayColor,				contentColor = kContentColor;	RgnHandle	tempRgn = NULL;		if( !theRgn )		return;		// Erase window frame area:	tempRgn = NewRgn();			CalcStructureRegion( theRgn );			if( tempRgn && !gCollapsed )	{		CalcContentRegion( tempRgn );		DiffRgn( theRgn, tempRgn, theRgn );		DisposeRgn( tempRgn );	}		RGBForeColor( &contentColor );	PaintRgn( theRgn );		if( !IsWindowHilited( gWindow ) && gHasColor )		RGBForeColor( &grayCol );	else		ForeColor( blackColor );	FrameRgn( theRgn );		// Draw dropshadow:	MoveTo( (**theRgn).rgnBBox.right -2,	(**theRgn).rgnBBox.top +1 );	LineTo( (**theRgn).rgnBBox.right -2,	(**theRgn).rgnBBox.bottom -2 );	LineTo( (**theRgn).rgnBBox.left +1,		(**theRgn).rgnBBox.bottom -2 );		// Title bar:	DrawTitleBar();		// Draw window title:	DrawTitleText();		// Draw close box:	if( GetWindowGoAwayFlag( gWindow ) && IsWindowHilited( gWindow ) )	{		SetGadgetFlag( false );		DrawCloseBox();	}		// Draw zoom box:	if( GetWindowZoomFlag( gWindow ) && IsWindowHilited( gWindow ) )	{		SetGadgetFlag( false );		DrawZoomBox();	}		// Draw collapse box:	if( IsWindowHilited( gWindow ) )	{		SetGadgetFlag( false );		DrawCollapseBox();		SetGadgetFlag( true );	}		// Draw grow box:	DrawGrowBox();	  #if _UW_THICK_BORDER	{		RGBColor		mediumCol,						lightCol;		Rect			box;				GetIndexedWindowColor( wTingeDark, &mediumCol );		GetIndexedWindowColor( wTingeLight, &lightCol );		MixColors( &mediumCol, &lightCol, &mediumCol );				box = (**theRgn).rgnBBox;		box.top += kBorderWidth -1;		InsetRect( &box, 1, 1 );		--box.right;		--box.bottom;				RGBForeColor( &lightCol );		MoveTo( box.left,	box.top );		LineTo( box.left,	box.bottom -1 );				RGBForeColor( &mediumCol );		DrawRectParts( &box, DR_BotRight );	}  #endif		ForeColor( blackColor );		if( theRgn )		DisposeRgn( theRgn );}/* ————————————————————————————————————————————————————————————————————————————————	DrawTitleText:		Draw the window title at its place.			REVISIONS:		98-02-01	UK		Now calculate base line relative to top. Looks better.		98-01-31	UK		Created.   ————————————————————————————————————————————————————————————————————————————— */void	DrawTitleText(){	Rect		box;	Str255		str;	RGBColor	contentCol = kContentColor;		GetWTitle( gWindow, str );		GetTitleTextRect( &box );	if( gHasColor && IsWindowHilited( gWindow ) )		RGBForeColor( &contentCol );	else		ForeColor( whiteColor );	PaintRect( &box );		if( IsWindowHilited( gWindow ) || !gHasColor )		ForeColor( blackColor );	else	{		RGBColor	grayCol = kDisabledColor;		RGBForeColor( &grayCol );	}		MoveTo( box.left +4, box.top +gFontData.ascent -1 );	DrawString( str );		ForeColor( blackColor );}/* ————————————————————————————————————————————————————————————————————————————————	DrawTitleBar:		Draw the contents of the title bar.			REVISIONS:		98-01-31	UK		Created.   ————————————————————————————————————————————————————————————————————————————— */void	DrawTitleBar(){	Rect		box;	short		vCoord;	RGBColor	lightCol,				mediumCol,				contentCol = kContentColor,				grayCol = kGrayColor;		GetTitleBarRect( &box, false );  #if !(_UW_THICK_BORDER)	FrameRect( &box );  #endif		if( gHasColor )	{		InsetRect( &box, 1, 1 );		GetIndexedWindowColor( wTingeLight, &lightCol );		GetIndexedWindowColor( wTingeDark, &mediumCol );		MixColors( &lightCol, &mediumCol, &mediumCol );				if( IsWindowHilited( gWindow ) )			RGBForeColor( &contentCol );		else			ForeColor( whiteColor );		PaintRect( &box );				if( IsWindowHilited( gWindow ) )		{			RGBForeColor( &lightCol );			DrawRectParts( &box, DR_TopLeft );						RGBForeColor( &mediumCol );			DrawRectParts( &box, DR_BotRight );		}				RGBForeColor( &grayCol );	}		/* Draw rallye stripes or dotted lines. For the latter we have two grey patterns which		are just the inverted version of the other. One is used for odd offsets, the other		for even ones. This avoids problems with pattern alignment after moving a window. */	if( IsWindowHilited( gWindow ) )	{	  #if _UW_DRAW_AS_PALETTE		long		oneGreyPat[2] = { 0xAA55AA55, 0xAA55AA55 },					twoGreyPat[2] = { 0x55AA55AA, 0x55AA55AA },					aBlackPat[2] = { 0xFFFFFFFF, 0xFFFFFFFF };	  #endif				GetTitleBarRect( &box, false );			  #if _UW_DRAW_AS_PALETTE		if( box.left & 1 )	// Odd?			PenPat( (Pattern*) oneGreyPat );		else			PenPat( (Pattern*) twoGreyPat );	  #endif	  		vCoord = box.top +4;				for( ; vCoord < box.bottom -4; vCoord += 2 )		{			MoveTo( box.left +2, vCoord );			LineTo( box.right -2 -1, vCoord );	// Balance that lines fall off to the lower right.		}	  #if _UW_DRAW_AS_PALETTE		PenPat( (Pattern*) aBlackPat );	  #endif	}		if( gHasColor )		ForeColor( blackColor );}/* ————————————————————————————————————————————————————————————————————————————————	DrawCloseBox:		Hilite/Unhilite the window's close box. Use the UlisWStateData record's		gadget field to check whether you've been highlighted or not.			REVISIONS:		98-01-30	UK		Created.   ————————————————————————————————————————————————————————————————————————————— */void	DrawCloseBox(){	Rect		box;		GetCloseBoxRect( &box );	DrawGadget( &box, GetGadgetFlag() );		SetGadgetFlag( !GetGadgetFlag() );	// Make sure flag is toggled.}/* ————————————————————————————————————————————————————————————————————————————————	DrawZoomBox:		Hilite/Unhilite the window's zoom box. Use the UlisWStateData record's		gadget field to check whether you've been highlighted or not.			REVISIONS:		98-01-30	UK		Created.   ————————————————————————————————————————————————————————————————————————————— */void	DrawZoomBox(){	Rect		box;		GetZoomBoxRect( &box );	DrawGadget( &box, GetGadgetFlag() );		if( !GetGadgetFlag() )	{		if( gHasColor )		{			RGBColor		darkCol;			const short		balance = HEIGHT(box) < 9 ? 0 : 1;						GetIndexedWindowColor( wTitleBarDark, &darkCol );			RGBForeColor( &darkCol );						if( BIT_TEST( gVariation, kUlisHasHorzZoomBox )				&& BIT_TEST( gVariation, kUlisHasVertZoomBox ) )			{				MoveTo( box.left +2,						box.top +(HEIGHT(box) /2) +balance );				LineTo( box.left +(WIDTH(box) /2) +balance,	box.top +(HEIGHT(box) /2) +balance );				LineTo( box.left +(WIDTH(box) /2) +balance,	box.top +2 );			}			else if( BIT_TEST( gVariation, kUlisHasVertZoomBox ) )			{				MoveTo( box.left +2,					box.top +(HEIGHT(box) /2) -1 );				LineTo( box.right -2,					box.top +(HEIGHT(box) /2) -1 );			}			else // kUlisHasHorzZoomBox			{				MoveTo( box.left +(WIDTH(box) /2) -1,	box.top +2 );				LineTo( box.left +(WIDTH(box) /2) -1,	box.bottom -2 );			}						ForeColor( blackColor );		}		else		{			if( BIT_TEST( gVariation, kUlisHasHorzZoomBox )				&& BIT_TEST( gVariation, kUlisHasVertZoomBox ) )			{				MoveTo( box.left,						box.top +(HEIGHT(box) /2) +1 );				LineTo( box.left +(WIDTH(box) /2) +1,	box.top +(HEIGHT(box) /2) +1 );				LineTo( box.left +(WIDTH(box) /2) +1,	box.top );			}			else if( BIT_TEST( gVariation, kUlisHasVertZoomBox ) )			{				MoveTo( box.left,						box.top +(HEIGHT(box) /2) -1 );				LineTo( box.right -1,					box.top +(HEIGHT(box) /2) -1 );			}			else // kUlisHasHorzZoomBox			{				MoveTo( box.left +(WIDTH(box) /2) -1,	box.top );				LineTo( box.left +(WIDTH(box) /2) -1,	box.bottom -1 );			}		}	}		SetGadgetFlag( !GetGadgetFlag() );	// Make sure flag is toggled.}/* ————————————————————————————————————————————————————————————————————————————————	DrawCollapseBox:		Hilite/Unhilite the window's collapse box. Use the UlisWStateData record's		gadget field to check whether you've been highlighted or not.			REVISIONS:		98-01-30	UK		Created.   ————————————————————————————————————————————————————————————————————————————— */long	DrawCollapseBox(){	Rect		box;		GetCollapseBoxRect( &box );	DrawGadget( &box, GetGadgetFlag() );		if( !GetGadgetFlag() )	{		if( gHasColor )		{			RGBColor		darkCol;						GetIndexedWindowColor( wTitleBarDark, &darkCol );			RGBForeColor( &darkCol );						MoveTo( box.left +2,		box.top +(HEIGHT(box) /2) -1 );			LineTo( box.right -1 -2,	box.top +(HEIGHT(box) /2) -1 );						MoveTo( box.left +2,		box.top +(HEIGHT(box) /2) +1 );			LineTo( box.right -1 -2,	box.top +(HEIGHT(box) /2) +1 );						ForeColor( blackColor );		}		else		{			MoveTo( box.left,		box.top +(HEIGHT(box) /2) -1 );			LineTo( box.right -1,	box.top +(HEIGHT(box) /2) -1 );						MoveTo( box.left,		box.top +(HEIGHT(box) /2) +1 );			LineTo( box.right -1,	box.top +(HEIGHT(box) /2) +1 );		}	}		SetGadgetFlag( !GetGadgetFlag() );	// Make sure flag is toggled.		return 0;}/* ————————————————————————————————————————————————————————————————————————————————	DrawGrowBox:		Draw the grow box into the window. Ths scrollbar lines are drawn by		DrawScrollbarLines() below. Don't do that here.			REVISIONS:		98-01-31	UK		Created.   ————————————————————————————————————————————————————————————————————————————— */void	DrawGrowBox(){	Rect		box;		GetGlobalWRect( &box );		if( BIT_TEST( gVariation, kUlisHasGrowBox ) )	{		RGBColor		lightCol,						grayCol = kGrayColor,						contentCol = kContentColor;		long			thePat[2] = { 0xFFFFFFFF, 0xFFFFFFFF };	// 100 % plack pattern.				GetGrowBoxRect( &box, false );				// Frame grow box:	  #if _UW_THEME_GROWBOX && GENERATINGCFM		DrawThemePlacard( &box, IsWindowHilited( gWindow ) ? kThemeStateActive : kThemeStateDisabled );		InsetRect( &box, 1, 1 );	  #else	  	GetIndexedWindowColor( wTingeLight, &lightCol );		if( !IsWindowHilited( gWindow ) && gHasColor )			RGBForeColor( &grayCol );		DrawRectParts( &box, DR_TopLeft );		InsetRect( &box, 1, 1 );				// Erase background:		if( gHasColor && IsWindowHilited( gWindow ) )			RGBForeColor( &contentCol );		else if( gHasColor )		  #if GENERATINGCFM			SetThemePen( kThemeFinderWindowBackgroundBrush, gMaxBitDepth, gHasColor );		  #else			RGBForeColor( &contentCol );		  #endif		else			ForeColor( whiteColor );		PaintRect( &box );		PenPat( (Pattern*) thePat );		ForeColor( blackColor );	  #endif				// Draw grow icon:		if( IsWindowHilited( gWindow ) )		{			// Large box:			InsetRect( &box, kUlisGrowBoxBorder, kUlisGrowBoxBorder );			++box.left;			++box.top;						DrawOneBox( &box );						// small box:			OffsetRect( &box, -1, -1 );			box.right -= (kUlisGrowBoxSize / 4) -1;			box.bottom -= (kUlisGrowBoxSize / 4) -1;						DrawOneBox( &box );		}				ForeColor( blackColor );	}}/* ————————————————————————————————————————————————————————————————————————————————	DrawScrollbarLines:		Draw the grow box lines that signal where the scrollbars should go into		the window. We do this in the window's GrafPort.			REVISIONS:		98-01-31	UK		Created.   ————————————————————————————————————————————————————————————————————————————— */void	DrawScrollbarLines( Rect *frame ){	Rect		box,				winBox;		if( !BIT_TEST( gVariation, kUlisHasGrowBox ) )		return;		if( frame == NULL )		box = gWindow->portRect;	else		box = *frame;			winBox = box;		GetGrowBoxRect( &box, true );		MoveTo( winBox.left, box.top );	LineTo( winBox.right -1, box.top );		MoveTo( box.left, winBox.top );	LineTo( box.left, winBox.bottom -1 );}#pragma mark -#pragma mark [Regions]/* ————————————————————————————————————————————————————————————————————————————————	CalcTitleBarRegion:		Calculate the region the title bar of this window occupies and store it in		the region passed.			REVISIONS:		98-01-31	UK		Created.   ————————————————————————————————————————————————————————————————————————————— */void	CalcTitleBarRegion( RgnHandle theRgn ){	Rect		box;		GetTitleBarRect( &box, false );		OpenRgn();	FrameRect( &box );	CloseRgn( theRgn );}/* ————————————————————————————————————————————————————————————————————————————————	CalcTitleTextRegion:		Calculate the region the window title of this window occupies and store it		in the region passed.			REVISIONS:		98-01-31	UK		Created.   ————————————————————————————————————————————————————————————————————————————— */void	CalcTitleTextRegion( RgnHandle theRgn ){	Rect		box;		GetTitleTextRect( &box );		OpenRgn();	FrameRect( &box );	CloseRgn( theRgn );}/* ————————————————————————————————————————————————————————————————————————————————	CalcCloseBoxRegion:		Calculate the region the close box of this window occupies and store it in		the region passed.			REVISIONS:		98-09-18	UK		Kept from including region if there's no close box.		98-01-31	UK		Created.   ————————————————————————————————————————————————————————————————————————————— */void	CalcCloseBoxRegion( RgnHandle theRgn ){	Rect		box = { 0, 0, 0, 0 };		if( GetWindowGoAwayFlag( gWindow ) )	{		OpenRgn();		GetCloseBoxRect( &box );		FrameRect( &box );		CloseRgn( theRgn );	}	else		SetEmptyRgn( theRgn );}/* ————————————————————————————————————————————————————————————————————————————————	CalcZoomBoxRegion:		Calculate the region zoom box of this window occupies and store it in		the region passed.			REVISIONS:		98-09-18	UK		Kept from including region if there's no zoom box.		98-01-31	UK		Created.   ————————————————————————————————————————————————————————————————————————————— */void	CalcZoomBoxRegion( RgnHandle theRgn ){	Rect		box = { 0, 0, 0, 0 };		if( GetWindowZoomFlag( gWindow ) )	{		OpenRgn();		GetCloseBoxRect( &box );		FrameRect( &box );		CloseRgn( theRgn );	}	else		SetEmptyRgn( theRgn );}/* ————————————————————————————————————————————————————————————————————————————————	CalcCollapseBoxRegion:		Calculate the region the collapse box of this window occupies and store it		in the region passed.				This makes a square region based on the title bar's height.			REVISIONS:		98-01-31	UK		Created.   ————————————————————————————————————————————————————————————————————————————— */void	CalcCollapseBoxRegion( RgnHandle theRgn ){	Rect		box;		GetCollapseBoxRect( &box );		OpenRgn();	FrameRect( &box );	CloseRgn( theRgn );}/* ————————————————————————————————————————————————————————————————————————————————	CalcTitleBarRegion:		Calculate the region the user can click in to move this window and store		it in the region passed.				This just calls CalcTitleBarRegion() and subtracts the gadgets if		necessary.			REVISIONS:		98-01-31	UK		Created.   ————————————————————————————————————————————————————————————————————————————— */void	CalcDragRegion( RgnHandle theRgn ){	CalcTitleBarRegion( theRgn );		if( IsWindowHilited( gWindow ) )	{		RgnHandle		tempRgn = NewRgn();				if( !tempRgn )			return;				// Subtract close box from drag region:		if( GetWindowGoAwayFlag( gWindow ) )		{			CalcCloseBoxRegion( tempRgn );			DiffRgn( theRgn, tempRgn, theRgn );		}				// Subtract zoom box from drag region:		if( GetWindowZoomFlag( gWindow ) )		{			CalcZoomBoxRegion( tempRgn );			DiffRgn( theRgn, tempRgn, theRgn );		}				// Subtract collapse box from drag region:		CalcCollapseBoxRegion( tempRgn );		DiffRgn( theRgn, tempRgn, theRgn );				DisposeRgn( tempRgn );	}}/* ————————————————————————————————————————————————————————————————————————————————	CalcGrowRegion:		Calculate the region the user can click in to grow the window and store it		in the region passed. This is usually the same as the region for the grow		box.			REVISIONS:		98-01-31	UK		Created.   ————————————————————————————————————————————————————————————————————————————— */void	CalcGrowRegion( RgnHandle theRgn ){	Rect		box;		if( BIT_TEST( gVariation, kUlisHasGrowBox ) )	{		OpenRgn();		GetGrowBoxRect( &box, false );		FrameRect( &box );		CloseRgn( theRgn );	}	else		SetEmptyRgn( theRgn );}/* ————————————————————————————————————————————————————————————————————————————————	CalcStructureRegion:		Calculate the region this window occupies and store it in the region		passed.				This simply calls all other window region routines. It also outsets the		content region to make sure it gets a 1 pixel frame and adds a shadow.			REVISIONS:		98-01-31	UK		Created.   ————————————————————————————————————————————————————————————————————————————— */void	CalcStructureRegion( RgnHandle theRgn ){	RgnHandle		tempRgn = NewRgn();		if( !tempRgn )		return;		// Outset content region by 1 so we get 1-pixel frame around content region:	if( !gCollapsed )	{		CalcContentRegion( theRgn );		InsetRgn( theRgn, -1, -1 );	}	else		SetEmptyRgn( theRgn );		// Add collapse box in case it's outside title bar:	CalcCollapseBoxRegion( tempRgn );	UnionRgn( theRgn, tempRgn, theRgn );		// Add grow box region in case it's outside title bar:	if( !gCollapsed )	{		if( BIT_TEST( gVariation, kUlisHasGrowBox ) )		{			CalcGrowRegion( tempRgn );			UnionRgn( theRgn, tempRgn, theRgn );		}	}		// Add zoom box region in case it's outside title bar:	if( GetWindowZoomFlag( gWindow ) )	{		CalcZoomBoxRegion( tempRgn );		UnionRgn( theRgn, tempRgn, theRgn );	}		// Add close box region in case it's outside title bar:	if( GetWindowGoAwayFlag( gWindow ) )	{		CalcCloseBoxRegion( tempRgn );		UnionRgn( theRgn, tempRgn, theRgn );	}		// We do this before the title bar is added since the title bar takes care of outsetting itself.  #if _UW_THICK_BORDER		InsetRgn( theRgn, -kBorderWidth, -kBorderWidth );		// Add MacOS 8-like border.  #endif		// Add title bar region:	CalcTitleBarRegion( tempRgn );	UnionRgn( theRgn, tempRgn, theRgn );		// Now make a copy and move it 1 pixel towards the lower right for the shadow effect:	CopyRgn( theRgn, tempRgn );	OffsetRgn( tempRgn, 1, 1 );	UnionRgn( theRgn, tempRgn, theRgn );		DisposeRgn( tempRgn );}/* ————————————————————————————————————————————————————————————————————————————————	CalcContentRegion:		Calculate the region the GrafPort of this window occupies and store it in		the region passed.			REVISIONS:		98-01-31	UK		Created.   ————————————————————————————————————————————————————————————————————————————— */void	CalcContentRegion( RgnHandle theRgn ){	Rect		box = { 0, 0, 0, 0 };		if( !gCollapsed )	{		OpenRgn();		GetGlobalWRect( &box );		FrameRect( &box );		if( BIT_TEST( gVariation, kUlisHasGrowBox ) )		{			GetGrowBoxRect( &box, false );			--box.right;			--box.bottom;			FrameRect( &box );		}		CloseRgn( theRgn );	}	else		SetEmptyRgn( theRgn );}/* ————————————————————————————————————————————————————————————————————————————————	CalcRegionsMessage:		Calculate the window regions and store them directly in the WindowPtr.		This is the old way of doing things (prior to MacOS 8) which we support,		too, so you can also use this under old OSs.			REVISIONS:		98-01-31	UK		Created.   ————————————————————————————————————————————————————————————————————————————— */void	CalcRegionsMessage(){	CalcContentRegion( ((WindowPeek) gWindow)->contRgn );	CalcStructureRegion( ((WindowPeek) gWindow)->strucRgn );}#pragma mark	-#pragma mark	[Rect Calculation]/* ————————————————————————————————————————————————————————————————————————————————	GetGlobalWRect:		Return our window's rect in global coordinates:			REVISIONS:		98-01-30	UK		Created.   ————————————————————————————————————————————————————————————————————————————— */void	GetGlobalWRect( Rect *aRect ){	GrafPtr		svPort;	Point		tempPoint;		GetPort( &svPort );	SetPort( gWindow );		(*aRect) = gWindow->portRect;		SetPt( &tempPoint, 0, 0 );	LocalToGlobal( &tempPoint );		OffsetRect( aRect, tempPoint.h, tempPoint.v );		SetPort( svPort );}/* ————————————————————————————————————————————————————————————————————————————————	GetTitleBarRect:		Calculate the rect for the title bar. Used by CalcTitleBarRegion().			REVISIONS:		98-02-01	UK		Now make sure that title bar contains an odd number							of rallye stripes.		98-01-31	UK		Created.   ————————————————————————————————————————————————————————————————————————————— */void	GetTitleBarRect( Rect* box, Boolean baseOnInput ){	if( !baseOnInput )		GetGlobalWRect( box );		box->bottom = box->top;	box->top = box->bottom -gFontData.ascent -gFontData.descent -2 -2;	box->left -= 1;	// Make larger 1pt so we are level with border.	box->right += 1;		if( !BIT_TEST( HEIGHT(*box), 1 ) )	// Odd number!		--box->top;	  #if _UW_THICK_BORDER	box->left -= kBorderWidth;	box->right += kBorderWidth;  #endif}/* ————————————————————————————————————————————————————————————————————————————————	GetTitleTextRect:		Calculate the rect for the window title. Used by CalcTitleTextRegion().			REVISIONS:		98-01-31	UK		Created.   ————————————————————————————————————————————————————————————————————————————— */void	GetTitleTextRect( Rect* box ){	Str255		wName;		GetWTitle( gWindow, wName );		if( wName[0] != 0 )	{	  #if _UW_CUSTOM_FONT		const short		titleWidth = StringWidth( wName );	  #else		const short		titleWidth = GetWindowTitleWidth( gWindow );	  #endif				GetTitleBarRect( box, false );				box->left += (WIDTH( *box ) /2) -(titleWidth / 2) -4;	// Center in title bar.		box->right = box->left +titleWidth +4 +4;		// Second +3 is there to balance the one above.		box->top += 3;		box->bottom -= 3;	}	else		box->left = box->right = box->top = box->bottom = 0;}/* ————————————————————————————————————————————————————————————————————————————————	GetGrowBoxRect:		Calculate the rect for the grow box. Used by CalcGrowRegion().			REVISIONS:		98-01-31	UK		Created.   ————————————————————————————————————————————————————————————————————————————— */void	GetGrowBoxRect( Rect* box, Boolean baseOnInput ){	if( !baseOnInput )		GetGlobalWRect( box );		box->bottom += 1;	// Make sure we are level with window frame.	box->right += 1;	box->left = box->right -kUlisGrowBoxSize;	box->top = box->bottom -kUlisGrowBoxSize;}/* ————————————————————————————————————————————————————————————————————————————————	GetCloseBoxRect:		Calculate the rect for the close box. Used by CalcCloseBoxRegion().			REVISIONS:		98-01-31	UK		Created.   ————————————————————————————————————————————————————————————————————————————— */void	GetCloseBoxRect( Rect* box ){	GetTitleBarRect( box, false );		box->top += 4;	box->bottom -= 4;	box->left += 8;	box->right = box->left +HEIGHT(*box);}/* ————————————————————————————————————————————————————————————————————————————————	GetZoomBoxRect:		Calculate the rect for the zoom box. Used by CalcZoomBoxRegion().			REVISIONS:		98-01-31	UK		Created.   ————————————————————————————————————————————————————————————————————————————— */void	GetZoomBoxRect( Rect* box ){	GetTitleBarRect( box, false );		box->top += 4;	box->bottom -= 4;	box->right -= 8 +2 +HEIGHT(*box);		// Leave space for collapse box.	box->left = box->right -HEIGHT(*box);}/* ————————————————————————————————————————————————————————————————————————————————	GetCollapseBoxRect:		Calculate the rect for the collapse box. Used by CalcCollapseBoxRegion().			REVISIONS:		98-01-31	UK		Created.   ————————————————————————————————————————————————————————————————————————————— */void	GetCollapseBoxRect( Rect* box ){	GetTitleBarRect( box, false );		box->top += 4;	box->bottom -= 4;	box->right -= 8;	box->left = box->right -HEIGHT(*box);}#pragma mark -#pragma mark	[Utility Routines]/* ————————————————————————————————————————————————————————————————————————————————	SetGadgetFlag:		Set the 'gadget' flag in our UlisWStateData record:			REVISIONS:		98-01-31	UK		Created.   ————————————————————————————————————————————————————————————————————————————— */void	SetGadgetFlag( Boolean state ){	Handle		theHandle = ((WindowPeek) gWindow)->dataHandle;		if( theHandle )		(**(UlisWStateDataHandle) theHandle).gadget = state;}/* ————————————————————————————————————————————————————————————————————————————————	GetGadgetFlag:		Return the 'gadget' flag from our UlisWStateData record:			REVISIONS:		98-01-30	UK		Created.   ————————————————————————————————————————————————————————————————————————————— */Boolean	GetGadgetFlag(){	Handle		theHandle = ((WindowPeek) gWindow)->dataHandle;		if( theHandle )		return (**(UlisWStateDataHandle) theHandle).gadget;	else		return false;}/* ————————————————————————————————————————————————————————————————————————————————	CheckColor:		Does the screen this window is on support colour?			REVISIONS:		98-01-30	UK		Created.   ————————————————————————————————————————————————————————————————————————————— */Boolean	CheckColor( WindowPtr winPtr ){	OSErr           theErr;	Boolean         hasColor = false;	GDHandle        aDevice;	long            theVal;	theErr = Gestalt( 'qdrw', &theVal );	if( theErr == noErr )		hasColor = BIT_TEST( theVal, 1 );	aDevice = GetMaxDevice( &((**(((WindowPeek) winPtr)->strucRgn)).rgnBBox) );	// Following fix is by Tom Reahard:	if( aDevice )	{		gMaxBitDepth = (**((**aDevice).gdPMap)).pixelSize;		hasColor = (hasColor && (gMaxBitDepth >= 4));	}	return( hasColor );}/* ————————————————————————————————————————————————————————————————————————————————	SetColorPort:		If we have colour, set the GrafPort to the Window Manager's CGrafPort		so we can draw in colour. This will automatically take along all settings		in the port.			REVISIONS:		98-01-30	UK		Created.   ————————————————————————————————————————————————————————————————————————————— */long	SetColorPort(){	CGrafPtr	aPort;	RgnHandle	myClip;	PenState	pnState;		if( gHasColor == true )	{		myClip = NewRgn();				if( !myClip )			return memFullErr;				GetCWMgrPort ( &aPort );				GetPenState ( &pnState );		GetClip( myClip );				SetPort( (GrafPtr) aPort );				SetPenState( &pnState );		SetClip( myClip );				DisposeRgn( myClip );	}		return 0;}/* ————————————————————————————————————————————————————————————————————————————————	DrawGadget:		Draw a generic gadget w/o contents. This is used for close, zoom and		collapse box.			REVISIONS:		98-01-31	UK		Created.   ————————————————————————————————————————————————————————————————————————————— */void	DrawGadget( Rect *frame, Boolean pressed ){	Rect		box = *frame;		// Erase gadget and lines to left and right:	box.left -= 1;	box.right += 1;		// Draw gadget:	if( gHasColor )	{		RGBColor	lightCol,					contentCol = kGadgetColor,					darkCol;				GetIndexedWindowColor( wTingeLight, &lightCol );		GetIndexedWindowColor( wTitleBarDark, &darkCol );				// Erase rallye stripes around us:		RGBForeColor( &lightCol );		PaintRect( &box );				box = *frame;				if( pressed )		{			// draw frame:			RGBForeColor( &darkCol );			FrameRect( &box );						// Draw content:			InsetRect( &box, 1, 1 );			RGBForeColor( &contentCol );			PaintRect( &box );						// Draw star:			ForeColor( blackColor );			DrawCloseBoxStar( &box );		}		else		{			// Draw upper-left shade:			RGBForeColor( &darkCol );			DrawRectParts( &box, DR_TopLeft );						// draw lower-right shade:			InsetRect( &box, 1, 1 );			box.top += 1;			box.left += 1;			DrawRectParts( &box, DR_BotRight );						// Draw gadget's content area:			box.right -= 1;	// So we don't draw on top of lower-right shade.			box.bottom -= 1;			RGBForeColor( &contentCol );			PaintRect( &box );						ForeColor( blackColor );		}	}	else	{		EraseRect( &box );				box = *frame;		FrameRect( &box );				if( pressed )		{			InsetRect( &box, 1, 1 );			DrawCloseBoxStar( &box );		}	}}/* ————————————————————————————————————————————————————————————————————————————————	DrawOneBox:		Draw one of the two boxes that are used for the grow box icon. This looks		almost like the box used for gadgets but its lower-right shade is moved 1		pixel towards the lower right.			REVISIONS:		98-01-31	UK		Created.   ————————————————————————————————————————————————————————————————————————————— */void	DrawOneBox( Rect *box ){	Rect			frame = *box;		if( gHasColor )	{		RGBColor		lightCol,						mediumCol = kGadgetColor,						darkCol;						GetIndexedWindowColor( wTingeLight, &lightCol );		GetIndexedWindowColor( wTitleBarDark, &darkCol );				RGBForeColor( &lightCol );		PaintRect( &frame );				RGBForeColor( &darkCol );		DrawRectParts( &frame, DR_TopLeft );						frame.left += 2;		frame.top += 2;		DrawRectParts( &frame, DR_BotRight );				RGBForeColor( &mediumCol );		--frame.bottom;		--frame.right;		PaintRect( &frame );	}	else	{		FrameRect( &frame );		InsetRect( &frame, 1, 1 );		EraseRect( &frame );	}}/* ————————————————————————————————————————————————————————————————————————————————	DrawCloseBoxStar:		Draw that strange char that's in the close box when it is pressed.			REVISIONS:		98-01-30	UK		Created.   ————————————————————————————————————————————————————————————————————————————— */void	DrawCloseBoxStar( Rect *frame ){	Rect			box = *frame;	const short		halfWidth = WIDTH(box) / 2,					halfHeight = HEIGHT(box) / 2;		// Since this rect was framed (and frames don't drop to lower right like our lines):	--box.right;	--box.bottom;		// Upper-left:	MoveTo( box.left +1,				box.top +1 );	LineTo( box.left +halfWidth -2,		box.top +halfHeight -2 );		// Upper-right:	MoveTo( box.right -1,				box.top +1 );	LineTo( box.right -halfWidth +2,	box.top +halfHeight -2 );		// Lower-right:	MoveTo( box.right -1,				box.bottom -1 );	LineTo( box.right -halfWidth +2,	box.bottom -halfHeight +2 );		// Lower-left:	MoveTo( box.left +1,				box.bottom -1 );	LineTo( box.left +halfWidth -2,		box.bottom -halfHeight +2 );		// Top:	MoveTo( box.left +halfWidth,		box.top );	LineTo( box.left +halfWidth,		box.top +halfHeight -2 );		// Right:	MoveTo( box.right,					box.top +halfHeight );	LineTo( box.right -halfWidth +2,	box.top +halfHeight );		// Bottom:	MoveTo( box.left +halfWidth,		box.bottom );	LineTo( box.left +halfWidth,		box.bottom -halfHeight +2 );		// Left:	MoveTo( box.left,					box.top +halfHeight );	LineTo( box.left +halfWidth -2,		box.top +halfHeight );}/* ————————————————————————————————————————————————————————————————————————————————	DrawRectParts:		Draw only the specified sides of a Rect.			REVISIONS:		98-01-30	UK		Created.   ————————————————————————————————————————————————————————————————————————————— */void	DrawRectParts( Rect *aRect, short choice ){	if( (choice & 1) == 1 )	{		MoveTo( (*aRect).left, (*aRect).top );		LineTo( (*aRect).right -1, (*aRect).top );	}	if( (choice & 2) == 2 )	{		MoveTo ( (*aRect).left, (*aRect).top );		LineTo ( (*aRect).left, (*aRect).bottom -1 );	}	if( (choice & 4) == 4 )	{		MoveTo ( (*aRect).left, (*aRect).bottom -1 );		LineTo ( (*aRect).right -1, (*aRect).bottom -1 );	}	if( (choice & 8) == 8 )	{		MoveTo ( (*aRect).right -1, (*aRect).top );		LineTo ( (*aRect).right -1, (*aRect).bottom -1 );	}}/* ————————————————————————————————————————————————————————————————————————————————	GetCurrentZoomState:		Compare the window rect to the standard state. If they're equal, we		are zooming in, else we're zooming out. This also sets the user state to		our rect so we can zoom back later.			REVISIONS:		98-01-31	UK		Adapted source from Troy Gaul.   ————————————————————————————————————————————————————————————————————————————— */long	GetCurrentZoomState(){	Rect		contentRect,				box;	long		result;		if( !((WindowPeek) gWindow)->dataHandle )		return wNoHit;		GetGlobalWRect( &contentRect );		GetWindowStandardState( gWindow, &box );	result = EqualRect( &contentRect, &box ) ? wInZoomIn : wInZoomOut;		if( result == wInZoomOut )		SetWindowUserState( gWindow, &contentRect );			return result;}/* ————————————————————————————————————————————————————————————————————————————————	GetIndexedWindowColor:		Retrieve a colour from the window's colour table. This uses Appearance's		accent colours 'clut' if it can be found, else calls GetWctbColor to		retrieve the colour.			REVISIONS:		98-01-31	UK		Created.   ————————————————————————————————————————————————————————————————————————————— */void	GetIndexedWindowColor( short partCode, RGBColor *col ){	CTabHandle	theTable;	  #ifndef GENERATINGCFM	if( GetThemeAccentColors( &theTable ) != noErr )  #endif		theTable = NULL;		if( theTable )	{		short		index;				switch( partCode )		{			case wTingeLight:			case wDialogLight:				index = 1;				break;						case wTingeDark:				index = 3;				break;						case wHiliteColorLight:			case wTitleBarLight:				index = 0;				break;						case wHiliteColorDark:			case wDialogDark:				index = 4;				break;						case wTitleBarDark:				index = 6;				break;						default:				index = 7;		}				*col = (**theTable).ctTable[index].rgb;	}	else		GetWctbColor( partCode, col );}/* ————————————————————————————————————————————————————————————————————————————————	GetWctbColor:		Retrieve a colour from the window's colour table.			REVISIONS:		98-01-31	UK		Adapted source from Troy Gaul.   ————————————————————————————————————————————————————————————————————————————— */void	GetWctbColor( short partCode, RGBColor *theColor ){	AuxWinHandle awHndl;	short count;		// Get the Color table for the window if it has one.	GetAuxWin( gWindow, &awHndl ); 	count = (**(WCTabHandle) (**awHndl).awCTable).ctSize;		// If the table didn’t contain the entry of interest, look to the 	// default table.	if( count < partCode )	{		GetAuxWin( nil, &awHndl ); 		count = (**(WCTabHandle) (**awHndl).awCTable).ctSize;	}		// If the entry is there, use it, if not make a best guess at a default value.	if( count < partCode )		GuessWctbColor( partCode, theColor );	else		*theColor = (**(WCTabHandle) (**awHndl).awCTable).ctTable[partCode].rgb;}/* ————————————————————————————————————————————————————————————————————————————————	GuessWctbColor:		Use a hard-coded value for a Wctb colour. Used by GetWctbColor whenever		a colour can't be found in any of the colour tables.			REVISIONS:		98-01-31	UK		Copied source from Troy Gaul.   ————————————————————————————————————————————————————————————————————————————— */void	GuessWctbColor( short index, RGBColor *theColor ){	switch( index )	{		case wContentColor:			//	 0		case wTitleBarColor:		//	 4		case wHiliteColorLight:		//	 5		case wTitleBarLight:		//	 7			theColor->red = theColor->green = theColor->blue = 0xFFFF;			break;						case wDialogLight:			//	 9		case wTingeLight:			//	11			theColor->red = theColor->green = 0xCCCC;			theColor->blue = 0xFFFF;			break;				case wTingeDark:			//	12			theColor->red = theColor->green = 0x3333;			theColor->blue = 0x6666;			break;		default:			theColor->red = theColor->green = theColor->blue = 0;			break;	}}